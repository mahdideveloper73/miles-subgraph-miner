package com.uantwerp.algorithms;

import java.io.File;
import java.util.Iterator;

import com.uantwerp.algorithms.common.GraphParameters;
import com.uantwerp.algorithms.exceptions.SubGraphMiningException;
import com.uantwerp.algorithms.utilities.AlgorithmUtility;
import com.uantwerp.algorithms.utilities.HashFuctions;
import com.univocity.parsers.csv.CsvParser;
import com.univocity.parsers.csv.CsvParserSettings;

public abstract class HashGeneration {
	
	/**
	 * Go through contents of input files and generate appropriate HashTables
	 * that are then stored inside the GraphParameters.graph attributes
	 * 
	 * The GraphParameter attributes for each file are file objects that point to the file paths.
	 * They are generated by the ParameterConfig class. 
	 * If an input file was not supplied, its variable will contain "null".
	 * 
	 * The following conditional is used to check for the existence of files
	 * if (GraphParameters.interestFile != null && GraphParameters.interestFile.exists() && GraphParameters.interestFile.length() != 0) {
	 * 
	 * The first part checks whether or not an input file was provided (GraphParameters.FILE defaults to null otherwise).
	 * The second and third part check whether the supplied file exists. The two statements can be condensed into
	 * just the last statement, because it will output 0 if the file does not exist.
	 * The first statement has to be placed first, to prevent a NullPointerException from occurring
	 * when .exists() is supplied to a null variable.
	 */
	public static void graphGeneration(){		
		readGraph(GraphParameters.graphFile);
		readLabels(GraphParameters.labelsFile);
		readInterest(GraphParameters.interestFile);
		readBackground(GraphParameters.backgroundFile);
		GraphParameters.graph.possibleLabels = AlgorithmUtility.getPossibleLables();
	}

	/**
	 * 
	 * @param file	the input file as a String (see ParameterConfig and FileUtility.readFile)
	 */
	public static void readGraph(File file) {
		CsvParserSettings settings = new CsvParserSettings();
		settings.detectFormatAutomatically();
		CsvParser parser = new CsvParser(settings);
		for (String[] row : parser.iterate(file)) {
			GraphParameters.graph.edgeHash = HashFuctions.updateHashHashSet(GraphParameters.graph.edgeHash,
					row[0],row[1]);
			GraphParameters.graph.reverseEdgeHash = HashFuctions.updateHashHashSet(GraphParameters.graph.reverseEdgeHash,
								row[1],row[0]);
			// If not in single label mode, add empty labels to HashSet value of vertex key in HashMap
			if (GraphParameters.singleLabel == 0){
				GraphParameters.graph.vertex = HashFuctions.updateHashHashSet(GraphParameters.graph.vertex,
									row[0]," ");
				GraphParameters.graph.vertex = HashFuctions.updateHashHashSet(GraphParameters.graph.vertex,
									row[1]," ");
				// Also add labels to HashMap of labels and assign them a value
				if (!GraphParameters.graph.labelHash.containsKey(" "))
					GraphParameters.graph.labelHash.put(" ", 1);
				else
					// the value will constantly be overwritten, so the final value will equal the number of nodes
					GraphParameters.graph.labelHash.put(" ", GraphParameters.graph.labelHash.get(" ") + 1);
			}
		}
	}

	/**
	 * 
	 * @param file	the input file as a String (see ParameterConfig and FileUtility.readFile)
	 */
	public static void readLabels(File file) {
		CsvParserSettings settings = new CsvParserSettings();
		settings.detectFormatAutomatically();
		CsvParser parser = new CsvParser(settings);
		
		// the label file is optional...
		if (GraphParameters.labelsFile != null && GraphParameters.labelsFile.length() != 0) {
			for (String[] row : parser.iterate(file)) {
				// Labels will be added as a HashSet to a HashMap with vertex keys
				GraphParameters.graph.reverseVertex = HashFuctions.updateHashHashSet(GraphParameters.graph.reverseVertex,
																						row[1],row[0]);
				GraphParameters.graph.vertex = HashFuctions.updateHashHashSet(GraphParameters.graph.vertex,
						row[0],row[1]);
				// The OneLabel HashMap will be overwritten with the last label value found for each node
				GraphParameters.graph.vertexOneLabel.put(row[0], row[1]);
				GraphParameters.graph.reverseVertexOneLabel.put(row[1], row[0]);
				// Labels will also be added to the label HashMap and given a value
				if (!GraphParameters.graph.labelHash.containsKey(row[1]))
					GraphParameters.graph.labelHash.put(row[1], 1);
				else
				// This will overwrite the previous value, so the final value for the label key will equal its frequency
					GraphParameters.graph.labelHash.put(row[1], GraphParameters.graph.labelHash.get(row[1])+1);
			}
		} else {
			// ...unless the single label option is selected
			if (GraphParameters.singleLabel == 1) 
				SubGraphMiningException.exceptionNoFileSingleLabel();
		}
	}

	/**
	 * 
	 * @param file	the input file as a String (see ParameterConfig and FileUtility.readFile)
	 */
	public static void readInterest(File file) {
		CsvParserSettings settings = new CsvParserSettings();
		settings.detectFormatAutomatically();
		CsvParser parser = new CsvParser(settings);
		
		// if the interest file is supplied and not empty
		if (GraphParameters.interestFile != null && GraphParameters.interestFile.length() != 0) {
			for (String[] row : parser.iterate(file)) {
				// Check if nodes of interest occur in graph and add them to HashSet
				if (GraphParameters.graph.vertex.containsKey(row[0])){
					GraphParameters.graph.group.add(row[0]);
				}else
					SubGraphMiningException.exceptionVertexNotFound(row[0], "interesting");
			}
		} else {
			// add all vertices in the graph to both the interest group and background set
			GraphParameters.graph.group = HashFuctions.returnKeySetHash(GraphParameters.graph.vertex);
			Iterator<String> it = GraphParameters.graph.vertex.keySet().iterator();
			while (it.hasNext())
				GraphParameters.graph.bgnodes.add(it.next());
		}
	}

	/**
	 * 
	 * @param file	the input file as a String (see ParameterConfig and FileUtility.readFile)
	 */
	public static void readBackground(File file) {
		CsvParserSettings settings = new CsvParserSettings();
		settings.detectFormatAutomatically();
		CsvParser parser = new CsvParser(settings);
		
		// Background nodes are of no use when there is no interest file (or if it is empty)
		if (GraphParameters.interestFile != null && GraphParameters.interestFile.length() != 0) {

			// if background file is provided and not empty
			if (GraphParameters.backgroundFile != null && GraphParameters.backgroundFile.length() != 0) {

				for (String[] row : parser.iterate(file)) {

					// Check if background vertices occur in graph and add them to HashSet
					if (GraphParameters.graph.vertex.containsKey(row[0])) {
						GraphParameters.graph.bgnodes.add(row[0]);
					} else
						SubGraphMiningException.exceptionVertexNotFound(row[0], "background");
				}

			} else {
			// If no background file or an empty file (null) is provided,
			// add all graph nodes as background
				Iterator<String> it = GraphParameters.graph.vertex.keySet().iterator();
				while (it.hasNext())
					GraphParameters.graph.bgnodes.add(it.next());
			}

		// if no (or empty interest) file is supplied
		} else
			// but the background file is supplied, raise exception
			if (GraphParameters.backgroundFile != null && GraphParameters.backgroundFile.length() != 0)
				SubGraphMiningException.exceptionBackgroundWithoutInterest();
		}
}	
