package com.uantwerp.algorithms;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.Arrays;
import java.util.Iterator;

import com.opencsv.CSVParser;
import com.opencsv.CSVParserBuilder;
import com.opencsv.CSVReader;
import com.opencsv.CSVReaderBuilder;
import com.uantwerp.algorithms.common.GraphParameters;
import com.uantwerp.algorithms.exceptions.SubGraphMiningException;
import com.uantwerp.algorithms.utilities.AlgorithmUtility;
import com.uantwerp.algorithms.utilities.HashFuctions;

public abstract class HashGeneration {
	
	/**
	 * Go through contents of input files and generate appropriate HashTables
	 * that are then stored inside the GraphParameters.graph attributes
	 * 
	 * The GraphParameter attributes for each file are file objects that point to the file paths.
	 * They are generated by the ParameterConfig class. 
	 * If an input file was not supplied, its variable will contain "null".
	 * 
	 * The following conditional is used to check for the existence of files
	 * if (GraphParameters.interestFile != null && GraphParameters.interestFile.exists() && GraphParameters.interestFile.length() != 0) {
	 * 
	 * The first part checks whether or not an input file was provided (GraphParameters.FILE defaults to null otherwise).
	 * The second and third part check whether the supplied file exists. The two statements can be condensed into
	 * just the last statement, because it will output 0 if the file does not exist.
	 * The first statement has to be placed first, to prevent a NullPointerException from occurring
	 * when .exists() is supplied to a null variable.
	 * @throws IOException 
	 */
	public static void graphGeneration() throws IOException{		
		readGraph(GraphParameters.graphFile);
		readLabels(GraphParameters.labelsFile);
		readInterest(GraphParameters.interestFile);
		readBackground(GraphParameters.backgroundFile);
		GraphParameters.graph.possibleLabels = AlgorithmUtility.getPossibleLables();
	}

	/**
	 * 
	 * @param file	the input file as a file object (see ParameterConfig and FileUtility.readFile)
	 * @throws IOException 
	 */
	public static void readGraph(File file) throws IOException {
		
        CSVParser parser = new CSVParserBuilder().withSeparator(GraphParameters.delimiter).build();

		try (BufferedReader br = Files.newBufferedReader(file.toPath());
				CSVReader reader = new CSVReaderBuilder(br).withCSVParser(parser)
						.build()) {
			String line[];
			int lineCount = 0;
			while ((line = reader.readNext()) != null) {
				lineCount++;
				int numberOfElements = line.length;

				// skip empty rows
				if (numberOfElements == 0) continue;	
				
				// check number of entries
				if (numberOfElements != 2) {
					SubGraphMiningException.exceptionRowEntries(file.toPath(), lineCount, Arrays.toString(line));
				}
				
				// store vertices
				GraphParameters.graph.edgeHash = HashFuctions.updateHashHashSet(GraphParameters.graph.edgeHash,
						line[0],line[1]);
				GraphParameters.graph.reverseEdgeHash = HashFuctions.updateHashHashSet(GraphParameters.graph.reverseEdgeHash,
						line[1],line[0]);
				// If not in single label mode, add empty labels to HashSet value of vertex key in HashMap
				if (GraphParameters.singleLabel == 0){
					GraphParameters.graph.vertex = HashFuctions.updateHashHashSet(GraphParameters.graph.vertex,
							line[0]," ");
					GraphParameters.graph.vertex = HashFuctions.updateHashHashSet(GraphParameters.graph.vertex,
							line[1]," ");
					// Also add labels to HashMap of labels and assign them a value
					if (!GraphParameters.graph.labelHash.containsKey(" "))
						GraphParameters.graph.labelHash.put(" ", 1);
					else
						// the value will constantly be overwritten, so the final value will equal the number of nodes
						GraphParameters.graph.labelHash.put(" ", GraphParameters.graph.labelHash.get(" ") + 1);
				}
			}
		}
	}

	/**
	 * 
	 * @param file	the input file as a file object (see ParameterConfig and FileUtility.readFile)
	 * @throws IOException 
	 */
	public static void readLabels(File file) throws IOException {
		// the label file is optional...
		if (GraphParameters.labelsFile != null && GraphParameters.labelsFile.length() != 0) {
			
			CSVParser parser = new CSVParserBuilder().withSeparator(GraphParameters.delimiter).build();

			try (BufferedReader br = Files.newBufferedReader(file.toPath());
					CSVReader reader = new CSVReaderBuilder(br).withCSVParser(parser)
							.build()) {
				String line[];
				int lineCount = 0;
				while ((line = reader.readNext()) != null) {
					lineCount++;
					int numberOfElements = line.length;

					// skip empty rows
					if (numberOfElements == 0) continue;	
					
					// check number of entries
					if (numberOfElements != 2) {
						SubGraphMiningException.exceptionRowEntries(file.toPath(), lineCount, Arrays.toString(line));
					}
					
					// Labels will be added as a HashSet to a HashMap with vertex keys
					GraphParameters.graph.reverseVertex = HashFuctions.updateHashHashSet(GraphParameters.graph.reverseVertex,
																							line[1],line[0]);
					GraphParameters.graph.vertex = HashFuctions.updateHashHashSet(GraphParameters.graph.vertex,
							line[0],line[1]);
					// The OneLabel HashMap will be overwritten with the last label value found for each node
					GraphParameters.graph.vertexOneLabel.put(line[0], line[1]);
					GraphParameters.graph.reverseVertexOneLabel.put(line[1], line[0]);
					// Labels will also be added to the label HashMap and given a value
					if (!GraphParameters.graph.labelHash.containsKey(line[1]))
						GraphParameters.graph.labelHash.put(line[1], 1);
					else
					// This will overwrite the previous value, so the final value for the label key will equal its frequency
						GraphParameters.graph.labelHash.put(line[1], GraphParameters.graph.labelHash.get(line[1])+1);
				}
			}
		} else {
			// ...unless the single label option is selected
			if (GraphParameters.singleLabel == 1) 
				SubGraphMiningException.exceptionNoFileSingleLabel();
		}
	}

	/**
	 * 
	 * @param file	the input file as a file object (see ParameterConfig and FileUtility.readFile)
	 * @throws IOException 
	 */
	public static void readInterest(File file) throws IOException {
		// if the interest file is supplied and not empty
		if (GraphParameters.interestFile != null && GraphParameters.interestFile.length() != 0) {
			// perform enriched mining method
			GraphParameters.frequentMining = false;
			// loop through interesting nodes
			
			CSVParser parser = new CSVParserBuilder().withSeparator(GraphParameters.delimiter).build();

			try (BufferedReader br = Files.newBufferedReader(file.toPath());
					CSVReader reader = new CSVReaderBuilder(br).withCSVParser(parser)
							.build()) {
				String line[];
				int lineCount = 0;
				while ((line = reader.readNext()) != null) {
					lineCount++;
					int numberOfElements = line.length;

					// skip empty rows
					if (numberOfElements == 0) continue;	

					// check number of entries
					if (numberOfElements != 1) {
						SubGraphMiningException.exceptionRowEntries(file.toPath(), lineCount, Arrays.toString(line));
					}

					// Check if nodes of interest occur in graph and add them to HashSet
					if (GraphParameters.graph.vertex.containsKey(line[0])){
						GraphParameters.graph.group.add(line[0]);
					} else
						SubGraphMiningException.exceptionVertexNotFound(line[0], "interesting");
					}
				}
			}
		// perform frequent subgraph mining if no interest file is supplied
		else {
			GraphParameters.frequentMining = true;
			// which also requires a specified support value
			if (GraphParameters.supportcutoff != 0) {
				// add all vertices in the graph to both the interest group and background set
				GraphParameters.graph.group = HashFuctions.returnKeySetHash(GraphParameters.graph.vertex);
				Iterator<String> it = GraphParameters.graph.vertex.keySet().iterator();
				while (it.hasNext())
					GraphParameters.graph.bgnodes.add(it.next());
			} else {
				SubGraphMiningException.exceptionNoSupport();
			}
		}
	}

	/**
	 * 
	 * @param file	the input file as a file object (see ParameterConfig and FileUtility.readFile)
	 * @throws IOException 
	 */
	public static void readBackground(File file) throws IOException {
		// Background nodes are of no use when there is no interest file (or if it is empty)
		if (GraphParameters.interestFile != null && GraphParameters.interestFile.length() != 0) {

			// if background file is provided and not empty
			if (GraphParameters.backgroundFile != null && GraphParameters.backgroundFile.length() != 0) {

				CSVParser parser = new CSVParserBuilder().withSeparator(GraphParameters.delimiter).build();

				try (BufferedReader br = Files.newBufferedReader(file.toPath());
						CSVReader reader = new CSVReaderBuilder(br).withCSVParser(parser)
								.build()) {
					String line[];
					int lineCount = 0;
					while ((line = reader.readNext()) != null) {
						lineCount++;
						int numberOfElements = line.length;

						// skip empty rows
						if (numberOfElements == 0) continue;	
						
						// check number of entries
						if (numberOfElements != 1) {
							SubGraphMiningException.exceptionRowEntries(file.toPath(), lineCount, Arrays.toString(line));
						}

						// Check if background vertices occur in graph and add them to HashSet
						if (GraphParameters.graph.vertex.containsKey(line[0])) {
							GraphParameters.graph.bgnodes.add(line[0]);
						} else
							SubGraphMiningException.exceptionVertexNotFound(line[0], "background");
						}
					}
				}
			// If no background file or an empty file (null) is provided,
			else {
				// add all graph nodes as background
				Iterator<String> it = GraphParameters.graph.vertex.keySet().iterator();
				while (it.hasNext())
					GraphParameters.graph.bgnodes.add(it.next());
				}
			}
		// if no (or empty interest) file is supplied
		else
			// but the background file is supplied, raise exception
			if (GraphParameters.backgroundFile != null && GraphParameters.backgroundFile.length() != 0)
				SubGraphMiningException.exceptionBackgroundWithoutInterest();
		}
}
